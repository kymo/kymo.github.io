<h3 id="dp">状态压缩DP</h3>
<p>状态压缩一般适用于状态非常多的动态规划问题，之所以叫状态压缩DP，是因为在动态规划的过程中，通过位压缩技术，可以压缩状态空间，而状态压缩问题一般都伴随着问题的条件限制，比如说相邻不能相同，或者相隔n个单元不能相同等。</p>

<p>来个例子说明这个问题</p>

<p>对于poj 3254，问题抽离出来的大意是，有个一部分空格无法填入值的矩阵，然后让你在剩余空格中填入0或者1，并且相邻空格不能填1，问最终由多少种填法。</p>

<p>我们将一行填入0,1之后看成一个二进制数state，但是此时如果列数很多的情况的话，时间复杂度还是不可小觑的，所以当加入一些条件，比如上述问题中的相邻空格不能为1，就可以将状态进一步压缩，对于某个状态i，如果i &amp; (i « 1) 不为0 的话，说明此时i的二进制格式中，必然有相邻的1。所以进一步压缩，新的状态总数必然要减少很多。而新的state可以作为这一行的此时的状态，当然是否合法还需要按照当前行的可填入空格的情况而论的。</p>

<p>稍微分析可知，当第i行状态为state时，此时总的方案数必然是第i-1行合法状态的累加。</p>

<p>状态表示：dp[i][state] 表示第i行的状态为state，此时获得的最大方案数；</p>

<p>状态方程转移：dp[i][state] = Add(dp[i - 1][_state])，此时state为第i行状态，_state为第i-1行状态；</p>

<p>代码见：https://github.com/kymo/acm/blob/master/POJ/ztysdp_3254.cpp</p>

<h3 id="dp-1">树形DP</h3>

<p>由于树本身的递归特性，所以在树上进行DP则是再好不过的了，父节点的状态在递归的时候，通过栈返回的子节点的状态得到更新。这里举出两个例子。</p>

<p>例(poj2432):
有n个人，每个人有个给定的价值，并给出两两之间的上下级关系，求一个集合，使得集合元素不存在上下级关系，且他们的价值和最大？</p>

<p>稍微分析一下，得知某个节点的状态有两种，选入集合或者不选入集合。由此我们可以令：
D[i][0]表示不选节点i，以i节点为根节点的子树得到的最大值
D[i][1]表示选了节点i，以i节点为根节点的子树得到的最大值
由此可以得到我们的DP方程如下：</p>

<p>代码:<a href="https://github.com/kymo/acm/blob/master/POJ/2342.cpp">https://github.com/kymo/acm/blob/master/POJ/2342.cpp</a></p>

<p>POJ 1463题目大意如此，只不过在本题是安排士兵的位置，状态方程和</p>

<p>例(HDU 2196)
有n(n 最大为10^4)个节点的树，每条边有一定的距离，求距离每一个节点最远的距离值。
按照常规思路的话，可能是用最短路算法，但是n的数据范围不允许我们如此暴力。仔细分析下，在树的父子结构一定的情况下，每个节点最长的距离的值必然和子节点和父节点相关，</p>

