<h1 id="sub">SUB</h1>

<h2 id="socket">SOCKET</h2>

<h3 id="selecteoll-io">设置为非阻塞模式，可以设置SELECT/EOLL IO模型.将</h3>
<p>Read, Write, Accept作为Reactor函数传递给IO模型</p>

<h3 id="section">有新的连接发过来数据，利用解析任务解析该任务，然</h3>
<p>后将解析出来的数据按照类型生成新的对应任务丢到队
列中. 任务处理完成之后，设置该FD为写，并将写的容
一并返回.</p>

<h2 id="io">IO</h2>

<h3 id="select">Select</h3>

<h4 id="readsetwriteset">使用read_set和write_set处理连接和读写，并接受</h4>
<p>server 传递过来的回调函数指针作为事件处理方法</p>

<h3 id="epoll">Epoll</h3>

<h4 id="todo">TODO</h4>

<h2 id="taskmgr">TaskMgr</h2>

<h3 id="task">task</h3>

<h4 id="section-1">对任务的封装，单个任务会有自己运行的回掉函数，以</h4>
<p>及运行时的参数空间,运行run完成之后，这个run会将
数据写回缓冲区. 然后调用call_back函数，将结果写
会fd,不同的任务会继承该task, 计算任务可以由用户指
定运行的回调函数.</p>

<h3 id="taskhandler">task_handler</h3>

<h4 id="theadhandler">作为线程池的thead_handler，每次都会从任务队列</h4>
<p>中取一个任务进行运行</p>

<h2 id="threadmgr">ThreadMgr</h2>

<h3 id="thread">thread</h3>

<h4 id="threadhandler">对线程的封装，线程运行函数由thread_handler指定</h4>

<h3 id="threadhandler-1">thread_handler</h3>

<h4 id="handl">线程真正的实现逻辑，不同类型的线程有不同的handl</h4>
<p>er去处理，对于线程池中的handler会不断的从taskM
gr中取task进行处理</p>

<h3 id="threadpool">thread_pool</h3>

<h4 id="section-2">线程池模型,根据配置中的线程数启动每个线程分配一</h4>
<p>个handler</p>

<h2 id="pluginmgr">PluginMgr</h2>

<h2 id="dictmgr">DictMgr</h2>

<h2 id="configmgr">ConfigMgr</h2>

<h2 id="memorymgr">MemoryMgr</h2>
